<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>



<link rel="alternate" title="Devx: Latest Published Articles" href="http://services.devx.com/outgoing/devxfeed.xml" type="application/rss+xml">
<link rel="alternate" title="DevX: Latest Java Articles" href="http://services.devx.com/outgoing/javafeed.xml" type="application/rss+xml">
<link rel="alternate" title="DevX: Latest .NET Content" href="http://services.devx.com/outgoing/dotnet.xml" type="application/rss+xml">
<link rel="alternate" title="DevX: Latest XML Content" href="http://services.devx.com/outgoing/xmlfeed.xml" type="application/rss+xml">
<link rel="alternate" title="DevX: Latest Database Content" href="http://services.devx.com/outgoing/databasefeed.xml" type="application/rss+xml">
<link rel="alternate" title="DevX: Latest Enterprise Content" href="http://services.devx.com/outgoing/enterprisefeed.xml" type="application/rss+xml">
<link rel="alternate" title="DevX: Latest C++ Content" href="http://services.devx.com/outgoing/cplusfeed.xml" type="application/rss+xml">
<link rel="alternate" title="DevX: Latest Web Development Content" href="http://services.devx.com/outgoing/webdevfeed.xml" type="application/rss+xml">
<link rel="alternate" title="DevX: Latest Wireless Content" href="http://services.devx.com/outgoing/wirelessfeed.xml" type="application/rss+xml">
<link rel="alternate" title="DevX: Recent Tips" href="http://services.devx.com/outgoing/recentTipsFeed.xml" type="application/rss+xml">
<link rel="alternate" title="DevX: Open Source Articles" href="http://services.devx.com/outgoing/openSourceFeed.xml" type="application/rss+xml">
<link rel="alternate" title="DevX: Premier Club Only Content" href="http://services.devx.com/outgoing/PCpreviewFeed.xml" type="application/rss+xml">
<link rel="alternate" title="DevX: Office Professional Developer" href="http://services.devx.com/outgoing/officefeed.xml" type="application/rss+xml">
<link rel="alternate" title="DevX: Intel Optimizing Center" href="http://services.devx.com/outgoing/intelOptimizingCenterFeed.xml" type="application/rss+xml">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"><title>Designing Lookless Controls in Windows Presentation Foundation</title>

<link rel="stylesheet" type="text/css" href="Designing%20Lookless%20Controls%20in%20Windows%20Presentation%20Foundation_files/cps.css"> <link rel="stylesheet" type="text/css" href="Designing%20Lookless%20Controls%20in%20Windows%20Presentation%20Foundation_files/pf.css">
<meta name="keywords" content="">
<meta name="Description" content="Learning to use and design lookless controls can free your WPF applications from the boring monotony of gray buttons forever.">
<meta name="Topic" content="2140 Windows Presentation Foundation (Avalon) -- Products and Technologies :: Protocols/APIs :: Windows APIs :: Windows Presentation Foundation (Avalon)">
<script language="javascript" src="Designing%20Lookless%20Controls%20in%20Windows%20Presentation%20Foundation_files/globalFuncs.js"></script></head><body bgcolor="#fafae6">

	
	

	
	
	
	
		
		
	
	
	
	
	

		
		
    

	



		    
    	    
    

   
   

<script language="javascript">
function showSupportItem(itemName)
{
	if( articleSpptItems[itemName] )
	{
		var theURL = 'http://www.devx.com/dotnet/Article/34564/1763';
		theURL += '?supportItem='+articleSpptItems[itemName].number;
		popUpWindow(theURL, articleSpptItems[itemName].width, articleSpptItems[itemName].height);
	}
	else
		alert("Sorry, "+itemName+" could not be found.");
}
function SupportItem(number, width, height)
{
	this.number = number;
	this.width = width;
	this.height = height;
	return this;
}
articleSpptItems = new Object();
	
	
		
	articleSpptItems.sidebar1 = new SupportItem(1,600,400);
	
		
	articleSpptItems.sidebar2 = new SupportItem(2,600,250);
	
		
	articleSpptItems.figure1 = new SupportItem(3,253,285);
	
		
	articleSpptItems.figure2 = new SupportItem(4,253,285);
	

</script>









	
	



	
	<table border="0" cellpadding="0" cellspacing="0" width="100%">
		<tbody><tr>
			<td>
				<div><a href="http://www.devx.com/"><img alt="DevX HomePage" src="Designing%20Lookless%20Controls%20in%20Windows%20Presentation%20Foundation_files/4055.gif" border="0"></a></div>
			</td>
			<td>&nbsp;</td>
		</tr>
		<tr>
			<td class="topPrintHeader" align="left"><a href="http://www.devx.com/">http://www.devx.com</a></td>
			<td class="topPrintHeader" align="right">Printed from <a href="http://www.devx.com/dotnet/Article/34564">http://www.devx.com/dotnet/Article/34564</a></td>
		</tr>
		<tr>
		<td>&nbsp;</td>
		</tr>
	</tbody></table>
	
	<table border="0" cellpadding="0" cellspacing="0">
		<tbody><tr>
			<td>
				
					<div class="articleTitle">Designing Lookless Controls in Windows Presentation Foundation</div>
				
				
				
				
				
					<div class="articleDek"><br>Learning
to use and design lookless controls can free your WPF applications from
the boring monotony of gray buttons forever.&nbsp;<div>
				
				
				
					
					
						
						
						<div class="articleAuthor">
						
							by
							David Talbot
						
						
						
						
						</div>
					
								
			</div></div></td>
		</tr>
		<tr>
			<td><img src="Designing%20Lookless%20Controls%20in%20Windows%20Presentation%20Foundation_files/3595.gif" align="left" height="24" width="23"><!-- END DROPCAP - FIRST PARAGRAPH -->
hen Microsoft set about building the Windows Presentation Foundation,
one core goal was to create an environment for applications capable of
both two-dimensional and three-dimensional content simultaneously.
Using a traditional approach, this would have led to an abstract Button
class followed by Button2D and Button3D subclasses that would override
the painting rules. Tearing a page from the CSS-based Internet,
Microsoft also wanted the look and feel of all controls to be
controllable via styles that, when updated, would in turn update the
look and feel of every component of that type in the application.<br><br>
Microsoft's solution is called "Lookless" controls. A Lookless control is a control that defines the <i>behavior</i>
of a control without regard to how it will look when rendered. For
example, a button is a control that has a normal state, a mouseover
state and a clicked state. The appearance of the button could be
anything&#8212;from the familiar grey box to an obnoxiously spinning 3D
flaming corporate logo circa web design 1997 style.<br><br>
All WPF controls implement a default look&#8212;typically the same as the
corresponding last generation Windows Forms control. In this article
you'll see how to take that ugly grey button and transform it into a
glass-effect pill button for a drug information application.<br><br>
<b>Style Definition</b><br>
XAML styling for lookless controls owes a lot of its heritage to HTML
and CSS, and you can apply styling in similar ways. For example, you
can define the look for all buttons in an application, restrict it to
all buttons on a specific screen, to a designated group of buttons, or
to apply a special style for just one button. To do that, XAML allows
you to define the look of your components at several levels. In terms
of actual implementation, styles are applied to components and are then
available to sub-components. Logically, they can be applied to an
individual component, a page or window or in an external file that can
be shared by multiple pages, windows, or applications.<br><br>
Each option has its place: from one-offs, to page-specific items, to
styles you want applied universally across your application. When more
than one style could potentially apply to the same element, the XAML
renderer applies styles in order of precedence: Inline --&gt; Component
--&gt; External File. That's the same way CSS applies styles to
elements. Generally, "closer" styles take precedence over styles
defined further away from elements.<br><br>
You can apply inline styles directly to an element simply by adding the style dependency property to it:<br><br>
<pre><code>   &lt;Button Content="Button Label"&gt;
      &lt;Button.Style&gt;
      ...
      &lt;/Button.Style&gt;
   &lt;/Button&gt;
</code></pre>
For small projects or when you're in the initial development phases, you will most likely define your styles in the <span class="pf">&lt;Window.Resources&gt;</span> or <span class="pf">&lt;Page.Resources&gt;</span> of the XAML file you're currently working on. You can access styles defined in the <span class="pf">resources</span> section of a file throughout the file<br><br>
To define your styles in a separate file, create a XAML file with a root element of <span class="pf">&lt;ResourceDictionary&gt;</span> instead of <span class="pf">&lt;Window&gt;</span>. You can then reference that external XAML file in your application's window using the code below:<br><br>
<pre><code>   &lt;Window.Resources&gt;
     &lt;ResourceDictionary&gt;
       &lt;ResourceDictionary.MergedDictionaries&gt;
         &lt;ResourceDictionary Source="Resources/Common.xaml" /&gt;
       &lt;/ResourceDictionary.MergedDictionaries&gt;
     &lt;/ResourceDictionary&gt;
   &lt;/Window.Resources&gt;
</code></pre>
It's worth noting that if you use an external XAML file on the
currently released version of WPF for Visual Studio 2005, any attempt
to use the designer preview will error out complaining that, <span class="pf">"Value 'Resources\Common.xaml' cannot be assigned to the property 'Source'." </span>even
though the syntax is correct and will work if you run the application.
Due to this bug, you should build your styles in the resources section
of the page until you get them the way you want them, and only then
move them to an external resource file.<br><br>
<b>Style Targeting</b><br>
You can apply styles to all components of a given type, and any
component can reference a named style. The difference between the two
is set in the style definition itself. If the style tag defines an <span class="pf">x:Key</span> then that style will only be applied to components that specifically reference that style.<br><br>
The example below shows the declaration of a named style referenced by a button. The style is defined in the <span class="pf">Windows.Resources</span> section and the Button itself is somewhere in the main content area of the page:<br><br>
<table align="right" border="0" cellpadding="5" cellspacing="0" width="175">
<tbody><tr><td valign="top"><a href="javascript:showSupportItem('figure1');"><img alt="" src="Designing%20Lookless%20Controls%20in%20Windows%20Presentation%20Foundation_files/19230.jpg" border="0" height="171" width="175"></a></td><td width="12">&nbsp;</td></tr>
<tr><td class="smallfont"><a href="javascript:showSupportItem('figure1');">Figure 1</a>. The PillButton: The figure shows several buttons using the PillButton style, complete with reflection.</td></tr>
</tbody></table>
<pre><code>   &lt;Style x:Key="PillButton" TargetType="Button"&gt;
     ...
     &lt;Button Style=
       "{StaticResource PillButton}"&gt;Lungs&lt;/Button&gt;
</code></pre>
By not defining an <span class="pf">x:Key</span>, your style will be applied to all components on the page that match the <span class="pf">TargetType</span> attribute value. In the following example, all buttons on the page automatically get the style defined applied to them:<br><br>
<pre><code>   &lt;Style TargetType="Button"&gt;
     ...
   &lt;Button&gt;Lungs&lt;/Button&gt;
</code></pre>
<a href="javascript:showSupportItem('figure1');">Figure 1</a> shows three buttons defined using this style in their default state.<br><br>
<p>
				
											
					
											    
					    
					
<br><br>			
				
			</p></td>
		</tr>
		
	</tbody></table>
	
	
	<table border="0" cellpadding="0" cellspacing="0">
		<tbody><tr>
			<td>
				
				
				
				
				
				
								
			</td>
		</tr>
		<tr>
			<td><b>Building the Template</b><br>
The core of overriding the default look of a WPF component is to create
a Template setter as shown in the snippet below. For a complete listing
of the components look, see <span class="pf">Common.xaml</span> which you can find in both the <a href="#codeitemarea">downloadable source file</a> and in Listing 1:<br><br>
<pre><code>   &lt;Style TargetType="Button"&gt;
     &lt;Setter Property="Template"&gt;
       &lt;Setter.Value&gt;
         &lt;ControlTemplate TargetType="Button"&gt;
</code></pre>
It's important to note that you need to define the <span class="pf">TargetType</span>
in your style property in order for the proper dependency properties to
be available. Because different event triggers are available for
different types of components, this property helps determine what
events and options are available as setters. If the syntax of this
style property looks strange to you, you might want to take a look at
the sidebar <a href="javascript:showSupportItem('sidebar1');">WPF Oddities</a>.<br><br>
Once inside the <span class="pf">ControlTemplate</span>
tag, you're free to put any kind of component or container. It expects
only one component, so to do something more complex, your one component
will need to be a layout component that can contain more
sub-components, such as a Grid or StackPanel. The code example included
with this article uses a Border component and a few sub-border
components, one of which contains a StackPanel to hold multiple child
components inside of a single Border.<br><br>
Inside your template, one important tag is the <span class="pf">ContentPresenter</span>,
which is responsible for displaying the sub-component provided to the
usage of your template. For a button, this is typically the text label
provided to the button via the <span class="pf">Text</span> attribute:<br><br>
<pre><code>   &lt;ContentPresenter /&gt;
</code></pre>
The <span class="pf">ContentPresenter</span> itself
supports a number of dependency properties that allow you to customize
how you want sub-components to be handled. For most types of
components, it's enough to just include an empty <span class="pf">ContentPresenter</span> tag, just to get the included text rendered.<br><br>
<b>Responding to Events</b><br>
<table align="right" border="0" cellpadding="5" cellspacing="0" width="175">
<tbody><tr><td valign="top"><a href="javascript:showSupportItem('figure2');"><img alt="" src="Designing%20Lookless%20Controls%20in%20Windows%20Presentation%20Foundation_files/19231.jpg" border="0" height="171" width="175"></a></td><td width="12">&nbsp;</td></tr>
<tr><td class="smallfont"><a href="javascript:showSupportItem('figure2');">Figure 2</a>.
Mouseover Effect Applied: In this figure, the "Eyes" button has been
clicked, and the mouseover effect has added a shadow at the top and the
shine at the bottom.</td></tr>
</tbody></table>
Most components include some form of interactivity&#8212;and any form of
interactivity requires that something happen with the component to let
the user know that the component has accepted their input. The code
example included provides support only for a mouseover effect. When the
mouseover effect is applied it adds the shadow at the top of the button
and the shine at the bottom to create the look of a slight depression
in the button area. <a href="javascript:showSupportItem('figure2');">Figure 2</a> illustrates the mouse-over state of the "Eyes" button:<br><br>
<pre><code>   &lt;ControlTemplate.Triggers&gt;
   &lt;Trigger Property="IsMouseOver" Value="true"&gt;
     &lt;Setter TargetName="Border" 
       Property="Background" 
       Value="{StaticResource NormalBrush}" /&gt;
     &lt;Setter TargetName="TopHighlight" 
       Property="Background" 
       Value="{StaticResource ShadowInverted}"/&gt;
     &lt;Setter TargetName="BottomHighlight" 
       Property="Background" 
       Value="{StaticResource ShinyInverted}"/&gt;
   &lt;/Trigger&gt;
</code></pre>
You don't have to create the inverse state when working with events in
XAML. For example, the included code provides setters that set the
borders to use different gradients to invert the direction of the
highlight and shadow on the PillButton if <span class="pf">IsMouseOver=True</span>. You don't have to define an event for <span class="pf">IsMouseOver=False</span> to return these to a normal state.<br><br>
If your component contains a multiple components as the PillButton
does, you can address each of these items to change different style
properties on the elements by setting the <span class="pf">TargetName</span>. When defining the component's template, each component you define will need to have an <span class="pf">x:Name</span> attribute set if you want to be able to modify this element in your event triggers. In the setters of your event trigger, the <span class="pf">TargetName</span> correlates to the <span class="pf">x:Name</span> of the component defined in the template.<br><br>
Each component type has a multitude of events&#8212;many are unique to that
particular component type. For some help locating what events are
supported by a given WPF component, take a look at the <a href="javascript:showSupportItem('sidebar2');">What Events Can I Respond To?</a><br><br>
<b>Achieving the Glass Look</b><br>
The reflection is courtesy of a rectangle placed below the pill itself
that applies a few filters. This rectangle is automatically sized to
match the pill via the binding reference:<br><br>
<pre><code>   &lt;Rectangle 
   Height="{Binding Path=ActualHeight,ElementName=Border}"
   Width="{Binding Path=ActualWidth, ElementName=Border}"&gt;
</code></pre>
Within the rectangle, you can use a VisualBrush object that uses
another component as a source. In this case, the code uses the pill
button as the visual source. It then applies a group of filters chained
together that invert the image (mirror), apply a gradient transparency
to it (to make it fade), and apply a blur effect. The combined result
of these three filters on the rendered result of the pill button is the
coveted glass effect shown in <a href="javascript:showSupportItem('figure1');">Figure 1</a>.<br><br>
Because all this magic is done in real time using full binding, if you
animate the pill the reflection will move and resize with the pill.<br><br>
Lookless controls provide a powerful and flexible way to define
application look and feel while cleanly separating visual style from
behavior. For further exploration, look into styling other types of WPF
controls. Each control has unique properties and approaches that you'll
need to explore to figure out how to take each control to its
limits&#8212;and beyond.<br><br>
<p>
				
					</p><div class=""><i><b>David Talbot</b> is the vice
president of development for Data Systems International, a company that
develops case-management software for the social services industry. His
experience ranges from license-plate recognition using neural networks
to television set-top boxes to highly scalable Web applications. He is
also the author of Applied ADO.NET</i>.</div>							
					
				
											
											    
					    
					
					
<br><br>			
				
			</td>
		</tr>
		
	</tbody></table>
	





		
	

	
	

	
	
	
	
		
		
	
	
	
	
	
		
		
			
			
			
			
				
			
			
			
			
			
				<!-- cache: WT175_W1992v2_C34564v2  08/27/2007 04:10:49 -->
	
<table style="padding-top: 10px;" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td class="smallFont" align="center">DevX is a division of Jupitermedia Corporation <br>
© Copyright 2007 Jupitermedia Corporation. All Rights Reserved. <a href="http://www.internet.com/corporate/legal.html">Legal Notices</a></td></tr>
</tbody></table>


	


			
		
	
</body></html>