<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3c.org/TR/1999/REC-html401-19991224/loose.dtd">
<!-- saved from url=(0067)http://www.interact-sw.co.uk/iangblog/2007/02/14/wpfdefaulttemplate -->
<HTML xmlns="http://www.w3.org/1999/xhtml"><HEAD><TITLE>IanG on Tap: Default Templates in WPF</TITLE>
<META http-equiv=Content-Type content="text/html; charset=utf-8">
<META content="Ian Griffiths' Weblog" name=description><LINK id=ctl00_rssLink 
title=RSS href="../../../../rss2.0" type=application/rss+xml rel=alternate><LINK 
href="IanG on Tap Default Templates in WPF_files/blog.css" type=text/css 
rel=stylesheet>
<META content="MSHTML 6.00.2900.3199" name=GENERATOR></HEAD>
<BODY>
<DIV class=blogTitle>
<H1>IanG on Tap</H1>
<P id=ctl00_subtitle><A href="http://www.interact-sw.co.uk/iangblog/">Ian 
Griffiths in Weblog Form</A> (<A 
href="http://www.interact-sw.co.uk/iangblog/rss2.0">RSS 2.0</A>)</P></DIV>
<DIV class=blogRightColumn>
<SCRIPT type=text/javascript><!--
google_ad_client = "pub-5895148714260970";
google_ad_width = 234;
google_ad_height = 60;
google_ad_format = "234x60_as";
google_ad_type = "text_image";
//2007-05-08: IanG Blog
google_ad_channel = "1140968575";
google_color_border = "336699";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "008000";
//-->
</SCRIPT>

<SCRIPT src="IanG on Tap Default Templates in WPF_files/show_ads.js" 
type=text/javascript>
</SCRIPT>

<DIV class=blogNav>
<H3>Blog Navigation</H3>
<TABLE>
  <TBODY>
  <TR>
    <TD>
      <P><A href="http://www.interact-sw.co.uk/iangblog/2007/10/">October 
      (2007)</A></P></TD>
    <TD>
      <P>(1 items)</P></TD></TR>
  <TR>
    <TD>
      <P><A href="http://www.interact-sw.co.uk/iangblog/2007/09/">September 
      (2007)</A></P></TD>
    <TD>
      <P>(3 items)</P></TD></TR>
  <TR>
    <TD>
      <P><A href="http://www.interact-sw.co.uk/iangblog/2007/08/">August 
      (2007)</A></P></TD>
    <TD>
      <P>(1 items)</P></TD></TR>
  <TR>
    <TD>
      <P><A href="http://www.interact-sw.co.uk/iangblog/2007/07/">July 
      (2007)</A></P></TD>
    <TD>
      <P>(1 items)</P></TD></TR>
  <TR>
    <TD>
      <P><A href="http://www.interact-sw.co.uk/iangblog/2007/06/">June 
      (2007)</A></P></TD>
    <TD>
      <P>(2 items)</P></TD></TR>
  <TR>
    <TD>
      <P><A href="http://www.interact-sw.co.uk/iangblog/2007/05/">May 
      (2007)</A></P></TD>
    <TD>
      <P>(8 items)</P></TD></TR>
  <TR>
    <TD>
      <P><A href="http://www.interact-sw.co.uk/iangblog/2007/04/">April 
      (2007)</A></P></TD>
    <TD>
      <P>(2 items)</P></TD></TR>
  <TR>
    <TD>
      <P><A href="http://www.interact-sw.co.uk/iangblog/2007/03/">March 
      (2007)</A></P></TD>
    <TD>
      <P>(7 items)</P></TD></TR>
  <TR>
    <TD>
      <P><A href="http://www.interact-sw.co.uk/iangblog/2007/02/">February 
      (2007)</A></P></TD>
    <TD>
      <P>(2 items)</P></TD></TR>
  <TR>
    <TD>
      <P><A href="http://www.interact-sw.co.uk/iangblog/2007/01/">January 
      (2007)</A></P></TD>
    <TD>
      <P>(2 items)</P></TD></TR>
  <TR>
    <TD>
      <P><A href="http://www.interact-sw.co.uk/iangblog/2006/11/">November 
      (2006)</A></P></TD>
    <TD>
      <P>(1 items)</P></TD></TR>
  <TR>
    <TD>
      <P><A href="http://www.interact-sw.co.uk/iangblog/2006/10/">October 
      (2006)</A></P></TD>
    <TD>
      <P>(2 items)</P></TD></TR>
  <TR>
    <TD>
      <P><A href="http://www.interact-sw.co.uk/iangblog/2006/09/">September 
      (2006)</A></P></TD>
    <TD>
      <P>(1 items)</P></TD></TR>
  <TR>
    <TD>
      <P><A href="http://www.interact-sw.co.uk/iangblog/2006/06/">June 
      (2006)</A></P></TD>
    <TD>
      <P>(2 items)</P></TD></TR>
  <TR>
    <TD>
      <P><A href="http://www.interact-sw.co.uk/iangblog/2006/05/">May 
      (2006)</A></P></TD>
    <TD>
      <P>(4 items)</P></TD></TR>
  <TR>
    <TD>
      <P><A href="http://www.interact-sw.co.uk/iangblog/2006/04/">April 
      (2006)</A></P></TD>
    <TD>
      <P>(1 items)</P></TD></TR>
  <TR>
    <TD>
      <P><A href="http://www.interact-sw.co.uk/iangblog/2006/03/">March 
      (2006)</A></P></TD>
    <TD>
      <P>(5 items)</P></TD></TR>
  <TR>
    <TD>
      <P><A href="http://www.interact-sw.co.uk/iangblog/2006/01/">January 
      (2006)</A></P></TD>
    <TD>
      <P>(1 items)</P></TD></TR>
  <TR>
    <TD>
      <P><A href="http://www.interact-sw.co.uk/iangblog/2005/12/">December 
      (2005)</A></P></TD>
    <TD>
      <P>(3 items)</P></TD></TR>
  <TR>
    <TD>
      <P><A href="http://www.interact-sw.co.uk/iangblog/2005/11/">November 
      (2005)</A></P></TD>
    <TD>
      <P>(2 items)</P></TD></TR>
  <TR>
    <TD>
      <P><A href="http://www.interact-sw.co.uk/iangblog/2005/10/">October 
      (2005)</A></P></TD>
    <TD>
      <P>(2 items)</P></TD></TR>
  <TR>
    <TD>
      <P><A href="http://www.interact-sw.co.uk/iangblog/2005/09/">September 
      (2005)</A></P></TD>
    <TD>
      <P>(8 items)</P></TD></TR>
  <TR>
    <TD>
      <P><A href="http://www.interact-sw.co.uk/iangblog/2005/08/">August 
      (2005)</A></P></TD>
    <TD>
      <P>(7 items)</P></TD></TR>
  <TR>
    <TD>
      <P><A href="http://www.interact-sw.co.uk/iangblog/2005/06/">June 
      (2005)</A></P></TD>
    <TD>
      <P>(3 items)</P></TD></TR>
  <TR>
    <TD>
      <P><A href="http://www.interact-sw.co.uk/iangblog/2005/05/">May 
      (2005)</A></P></TD>
    <TD>
      <P>(7 items)</P></TD></TR>
  <TR>
    <TD>
      <P><A href="http://www.interact-sw.co.uk/iangblog/2005/04/">April 
      (2005)</A></P></TD>
    <TD>
      <P>(6 items)</P></TD></TR>
  <TR>
    <TD>
      <P><A href="http://www.interact-sw.co.uk/iangblog/2005/03/">March 
      (2005)</A></P></TD>
    <TD>
      <P>(1 items)</P></TD></TR>
  <TR>
    <TD>
      <P><A href="http://www.interact-sw.co.uk/iangblog/2005/02/">February 
      (2005)</A></P></TD>
    <TD>
      <P>(2 items)</P></TD></TR>
  <TR>
    <TD>
      <P><A href="http://www.interact-sw.co.uk/iangblog/2005/01/">January 
      (2005)</A></P></TD>
    <TD>
      <P>(5 items)</P></TD></TR>
  <TR>
    <TD>
      <P><A href="http://www.interact-sw.co.uk/iangblog/2004/12/">December 
      (2004)</A></P></TD>
    <TD>
      <P>(5 items)</P></TD></TR>
  <TR>
    <TD>
      <P><A href="http://www.interact-sw.co.uk/iangblog/2004/11/">November 
      (2004)</A></P></TD>
    <TD>
      <P>(7 items)</P></TD></TR>
  <TR>
    <TD>
      <P><A href="http://www.interact-sw.co.uk/iangblog/2004/10/">October 
      (2004)</A></P></TD>
    <TD>
      <P>(3 items)</P></TD></TR>
  <TR>
    <TD>
      <P><A href="http://www.interact-sw.co.uk/iangblog/2004/09/">September 
      (2004)</A></P></TD>
    <TD>
      <P>(7 items)</P></TD></TR>
  <TR>
    <TD>
      <P><A href="http://www.interact-sw.co.uk/iangblog/2004/08/">August 
      (2004)</A></P></TD>
    <TD>
      <P>(16 items)</P></TD></TR>
  <TR>
    <TD>
      <P><A href="http://www.interact-sw.co.uk/iangblog/2004/07/">July 
      (2004)</A></P></TD>
    <TD>
      <P>(10 items)</P></TD></TR>
  <TR>
    <TD>
      <P><A href="http://www.interact-sw.co.uk/iangblog/2004/06/">June 
      (2004)</A></P></TD>
    <TD>
      <P>(27 items)</P></TD></TR>
  <TR>
    <TD>
      <P><A href="http://www.interact-sw.co.uk/iangblog/2004/05/">May 
      (2004)</A></P></TD>
    <TD>
      <P>(15 items)</P></TD></TR>
  <TR>
    <TD>
      <P><A href="http://www.interact-sw.co.uk/iangblog/2004/04/">April 
      (2004)</A></P></TD>
    <TD>
      <P>(15 items)</P></TD></TR>
  <TR>
    <TD>
      <P><A href="http://www.interact-sw.co.uk/iangblog/2004/03/">March 
      (2004)</A></P></TD>
    <TD>
      <P>(13 items)</P></TD></TR>
  <TR>
    <TD>
      <P><A href="http://www.interact-sw.co.uk/iangblog/2004/02/">February 
      (2004)</A></P></TD>
    <TD>
      <P>(16 items)</P></TD></TR>
  <TR>
    <TD>
      <P><A href="http://www.interact-sw.co.uk/iangblog/2004/01/">January 
      (2004)</A></P></TD>
    <TD>
      <P>(15 items)</P></TD></TR></TBODY></TABLE>
<P id=ctl00_ctl01_pBlogHome><A 
href="http://www.interact-sw.co.uk/iangblog/">Blog Home</A></P>
<P id=ctl00_ctl01_pBlogRss><A 
href="http://www.interact-sw.co.uk/iangblog/rss2.0">RSS 2.0</A></P>
<H3>Writing</H3>
<P><A href="http://www.oreilly.com/catalog/9780596510374/">Programming 
WPF</A></P>
<P><A href="http://www.oreilly.com/catalog/netwinformian/">.NET Windows Forms in 
a Nutshell</A></P>
<P><A href="http://www.oreilly.com/catalog/mastvsnet/">Mastering Visual Studio 
.NET</A></P>
<H3>Other Sites</H3>
<P><A href="http://www.interact-sw.co.uk/">Interact Software</A></P></DIV></DIV>
<DIV class=blogBody>
<HR>

<H2>Default Templates in WPF - <SPAN class=blogDate>Wednesday 14 February, 2007, 
6:15 PM </SPAN></H2>
<DIV class=blogitem>
<P>Someone recently asked me how WPF controls get their default templates. If 
you create a built-in control such as <CODE>Button</CODE>, its 
<CODE>Template</CODE> property will automatically be set to a 
<CODE>ControlTemplate</CODE> that defines the appropriate appearance for that 
control. Most controls look different in the various Windows themes, so the 
exact template you get depends on which theme is running.</P>
<P>The question is: where does WPF get the default template from?</P>
<H3>Property Metadata</H3>
<P>The first obvious place to look is the property metadata. 
<CODE>Template</CODE>, like most properties of WPF controls, is a dependency 
property. This means it has metadata associated with it which, amongst other 
things, can define a default value. We can retrieve this like so:</P><PRE><SPAN style="COLOR: dimgray">Control</SPAN>.TemplateProperty.GetMetadata(<SPAN style="COLOR: blue">typeof</SPAN>(<SPAN style="COLOR: dimgray">Button</SPAN>)).DefaultValue
</PRE>
<P>This retrieves the default value that the <CODE>Template</CODE> property will 
have on an instance of <CODE>Button</CODE>. The reason we pass a 
<CODE>Type</CODE> into <CODE>GetMetadata</CODE> is that WPF lets a property have 
different metadata for different types. This allows a property to have different 
default values in different contexts. For example, the default value for the 
<CODE>Focusable</CODE> property is <CODE>False</CODE> for 
<CODE>UIElement</CODE>, but <CODE>Control</CODE> overrides this to 
<CODE>True</CODE>. (And <CODE>UserControl</CODE> overrides it back to 
<CODE>False</CODE> again.)</P>
<P>But this doesn't help us. It turns out that the default value for the 
<CODE>Template</CODE> property on a <CODE>Button</CODE> is null, as it is for 
other controls. So how does the property come to have a value by default?</P>
<H3>Styles</H3>
<P>The <CODE>Template</CODE> property gets its value from WPF's style system. 
The <CODE>Template</CODE> property is not special: lots of properties pick up 
their values this way. For example, if you are running the Windows Vista Aero 
theme, the <CODE>Button</CODE> has its <CODE>Background</CODE>, 
<CODE>Foreground</CODE>, <CODE>BorderBrush</CODE>, <CODE>BorderThickness</CODE>, 
<CODE>FocusVisualStyle</CODE>, <CODE>HorizontalContentAlignment</CODE>, 
<CODE>VerticalContentAlignment</CODE>, <CODE>Padding</CODE>, and 
<CODE>Template</CODE> properties all set by the style system. Although the 
<CODE>Template</CODE> may seem special because it gets to define the visuals for 
a control, it's still just another property.</P>
<P>There's one problem with this explanation. If you look at an ordinary WPF 
<CODE>Button</CODE> at runtime, its <CODE>Style</CODE> property will usually be 
null. How can the <CODE>Template</CODE> (and all these other properties) come 
from a style if <CODE>Style</CODE> is null?</P>
<H3>Explicit Style vs. Theme Style</H3>
<P>WPF elements can have two styles associated with them. The <CODE>Style</CODE> 
property can hold an 'explicit' style. (This is null by default, but can be set 
in a variety of ways.) But a control will also have a so-called theme style. And 
only the explicit style is directly visible, there is evidence of the presence 
of the theme style. For example, look at the <CODE>BaseValueSource</CODE> 
enumeration, which enumerates all the possible places that a dependency 
property's value may have come from. It includes both <CODE>Style</CODE> and 
<CODE>DefaultStyle</CODE> values, the latter indicating that the value came from 
the default style for the current theme. WPF returns a member of this 
enumeration when we ask it where it got the value for a particular property:</P><PRE><SPAN style="COLOR: dimgray">DependencyPropertyHelper</SPAN>.GetValueSource(myButton,
    <SPAN style="COLOR: dimgray">Button</SPAN>.TemplateProperty).BaseValueSource
</PRE>
<P>If <CODE>myButton</CODE> refers to a normal <CODE>Button</CODE> here, this 
will evaluate to <CODE>DefaultStyle</CODE>, indicating that the 
<CODE>Template</CODE> property came from the theme style. So we now know exactly 
how the <CODE>Template</CODE> property acquired its value...up to a point. Of 
course the next question is: where does this <CODE>DefaultStyle</CODE> come 
from? But first a quick digression.</P>
<H3>Why Two Styles?</H3>
<P>You might be wondering why elements need two styles. Well imagine if they 
only had one. Think what would happen with the following:</P><PRE><SPAN style="COLOR: blue">&lt;</SPAN><SPAN style="COLOR: brown">Grid</SPAN><SPAN style="COLOR: blue">&gt;</SPAN>
<SPAN style="COLOR: blue">  &lt;</SPAN><SPAN style="COLOR: brown">Grid.Resources</SPAN><SPAN style="COLOR: blue">&gt;</SPAN>
<SPAN style="COLOR: blue">    &lt;</SPAN><SPAN style="COLOR: brown">Style</SPAN><SPAN style="COLOR: blue"> </SPAN><SPAN style="COLOR: red">TargetType</SPAN><SPAN style="COLOR: blue">=</SPAN>"<SPAN style="COLOR: blue">{x:Type Button}</SPAN>"<SPAN style="COLOR: blue">&gt;</SPAN>
<SPAN style="COLOR: blue">      &lt;</SPAN><SPAN style="COLOR: brown">Setter</SPAN><SPAN style="COLOR: blue"> </SPAN><SPAN style="COLOR: red">Property</SPAN><SPAN style="COLOR: blue">=</SPAN>"<SPAN style="COLOR: blue">HorizontalAlignment</SPAN>"
             <SPAN style="COLOR: blue"> </SPAN><SPAN style="COLOR: red">Value</SPAN><SPAN style="COLOR: blue">=</SPAN>"<SPAN style="COLOR: blue">Center</SPAN>"<SPAN style="COLOR: blue"> /&gt;</SPAN>
<SPAN style="COLOR: blue">      &lt;</SPAN><SPAN style="COLOR: brown">Setter</SPAN><SPAN style="COLOR: blue"> </SPAN><SPAN style="COLOR: red">Property</SPAN><SPAN style="COLOR: blue">=</SPAN>"<SPAN style="COLOR: blue">VerticalAlignment</SPAN>"
             <SPAN style="COLOR: blue"> </SPAN><SPAN style="COLOR: red">Value</SPAN><SPAN style="COLOR: blue">=</SPAN>"<SPAN style="COLOR: blue">Center</SPAN>"<SPAN style="COLOR: blue"> /&gt;</SPAN>
<SPAN style="COLOR: blue">    &lt;/</SPAN><SPAN style="COLOR: brown">Style</SPAN><SPAN style="COLOR: blue">&gt;</SPAN>
<SPAN style="COLOR: blue">  &lt;/</SPAN><SPAN style="COLOR: brown">Grid.Resources</SPAN><SPAN style="COLOR: blue">&gt;</SPAN>

<SPAN style="COLOR: blue">  &lt;</SPAN><SPAN style="COLOR: brown">Button</SPAN><SPAN style="COLOR: blue"> </SPAN><SPAN style="COLOR: red">Content</SPAN><SPAN style="COLOR: blue">=</SPAN>"<SPAN style="COLOR: blue">Click me</SPAN>"<SPAN style="COLOR: blue"> /&gt;</SPAN>
<SPAN style="COLOR: blue">&lt;/</SPAN><SPAN style="COLOR: brown">Grid</SPAN><SPAN style="COLOR: blue">&gt;</SPAN>
</PRE>
<P>The <CODE>Button</CODE> in this example has an explicit style. It doesn't 
look all that explicit, since the <CODE>Style</CODE> property has not been set 
directly. However, we've put a <CODE>Style</CODE> with a <CODE>TargetType</CODE> 
of <CODE>Button</CODE>'s type object, and this has the effect of applying the 
<CODE>Style</CODE> to any <CODE>Button</CODE> inside that <CODE>Grid</CODE>.</P>
<P><B>Note:</B> what I've written here contradicts what the SDK currently says. 
It says that an explicit style is one that is "referenced by non-type Key" which 
suggests that this doesn't count as an explicit style. However, if we use the 
<CODE>DependencyPropertyHelper</CODE> to ask where the <CODE>Button</CODE> in 
this example got its <CODE>HorizontalAlignment</CODE> and 
<CODE>VerticalAlignment</CODE> properties from, it says: <CODE>Style</CODE>, 
which the documentation says means the value "is from a style setter of an 
explicit style."</P>
<P>So experimentation indicates that an 'explicit style' is one that is not the 
default style from the theme. I think the documentation for "Dependency Property 
Value Precedence" is simply misleading right now. In fact a simpler way of 
looking at it is this: an explicit style is the one in the <CODE>Style</CODE> 
property. Given the XAML above, if you read the <CODE>Button</CODE>'s 
<CODE>Style</CODE> property, you'll see that it actually contains a reference to 
the <CODE>Style</CODE> defined in the <CODE>Grid</CODE>'s resources.</P>
<P>Anyway, having cleared up that this is indeed an explicit style, why does 
this distinction matter? Suppose elements had just one style: what would happen 
to all the other properties normally set by the style in this case? Remember 
that <CODE>Background</CODE>, <CODE>Foreground</CODE>, <CODE>BorderBrush</CODE>, 
<CODE>BorderThickness</CODE>, <CODE>FocusVisualStyle</CODE>, 
<CODE>HorizontalContentAlignment</CODE>, <CODE>VerticalContentAlignment</CODE>, 
<CODE>Padding</CODE>, and <CODE>Template</CODE> all get their value from the 
theme style by default. If the theme style were simply replaced with the custom 
style shown above, all of these properties would revert to their unstyled 
defaults. And since the default value for <CODE>Template</CODE> is null, this 
means the control would lose its appearance!</P>
<P>You could solve this by setting a custom style's <CODE>BasedOn</CODE> 
property to refer to the original style. But that would be tedious, seeing as 
how every single style would need to do that. So instead, WPF just remembers the 
original theme style even when an explicit style is supplied. Setters in the 
explicit style take precedence over the theme style. But if the explicit style 
does not supply a setter for a property that the theme style does, the theme 
style gets to supply that property's value. This is why a control doesn't vanish 
the moment you supply a custom style: the default theme style is still in place, 
and will still supply the <CODE>Template</CODE> and various other properties if 
your custom style doesn't supply different values.</P>
<H3>Where Does The Theme Style Come From?</H3>
<P>We still don't really have a satisfactory answer to the original question. We 
now know that by default, a control's <CODE>Template</CODE> comes from the theme 
style. But where does the theme style come from? WPF defines a property to hold 
it. However, it's not public. This doesn't stop us from taking a look at it 
using a technique that YOU SHOULD <B>NOT</B> USE IN PRODUCTION CODE:</P><PRE><SPAN style="COLOR: dimgray">Style</SPAN> ts = <SPAN style="COLOR: blue">typeof</SPAN>(<SPAN style="COLOR: dimgray">Button</SPAN>).GetProperty(<SPAN style="COLOR: brown">"ThemeStyle"</SPAN>,
   <SPAN style="COLOR: dimgray">BindingFlags</SPAN>.NonPublic | <SPAN style="COLOR: dimgray">BindingFlags</SPAN>.Instance).GetValue(myButton,
   <SPAN style="COLOR: blue">null</SPAN>) <SPAN style="COLOR: blue">as</SPAN> <SPAN style="COLOR: dimgray">Style</SPAN>;
</PRE>
<P>By all means do that to satisfy you're curiosity, but <I>please</I> don't do 
that in live code, because there's no guarantee that property will be there in 
future versions of WPF. In any case, we don't need to do that. As long as you've 
not defined a custom default style at the application scope, the following code 
will find the system style:</P><PRE><SPAN style="COLOR: dimgray">Style</SPAN> ts = <SPAN style="COLOR: dimgray">Application</SPAN>.Current.FindResource(<SPAN style="COLOR: blue">typeof</SPAN>(<SPAN style="COLOR: dimgray">Button</SPAN>));
</PRE>
<P>You can verify for yourself that this returns the very same object instance. 
But why would it do that? Well, when you call <CODE>FindResource</CODE> on 
<CODE>Application</CODE> (or a <CODE>FrameworkElement</CODE> for that matter) it 
will walk its way up the resource tree, and eventually hit the system scope. The 
system scope is where the default theme styles are defined. (And in fact, WPF 
goes straight to the system scope when locating the default theme style. 
However, there's no public API for doing that, which is why the code shown here 
starts at the application scope instead; it still ends up at the system 
scope.)</P>
<H3>Where Does The System Scope Come From?</H3>
<P>The answer is still not looking especially concrete. We know that the 
<CODE>Template</CODE> property typically gets its default value from the theme 
style, and that the theme style comes from the system scope resources. But where 
do those come from? If you've ever written a custom control, then you'll know, 
because the way custom controls add theme-specific resources to the system scope 
turns out to be the same as the way WPF adds its own theme-specific resource to 
the same scope.</P>
<P>It works like this. Style resources are identified by a <CODE>Type</CODE> 
object. And when WPF looks for a style in the system scope, it looks at the 
identifying <CODE>Type</CODE> object's <CODE>Assembly</CODE> property. It 
examines that assembly for a <CODE>ThemeInfo</CODE> custom attribute. If that 
attribute is present, WPF examines its <CODE>ThemeInfoDictionaryLocation</CODE> 
property. If this is set to <CODE>None</CODE>, then it knows no theme-specific 
resources are present for this type. Otherwise, if it is set to 
<CODE>SourceAssembly</CODE>, it knows that the assembly that defines the type 
also contains theme-specific resources. If it is set to 
<CODE>ExternalAssembly</CODE>, it knows that theme-specific resources are 
available in a separate assembly whose name is formed by adding the theme name 
to the base assembly name.</P>
<P>Let's follow that through with <CODE>Button</CODE>. The <CODE>Button</CODE> 
type is defined in the <CODE>PresentationFramework</CODE> assembly. This 
assembly has the <CODE>ThemeInfo</CODE> attribute applied, and the 
<CODE>ThemeInfoDictionaryLocation</CODE> is set to 
<CODE>ExternalAssembly</CODE>. This means that if we're running the Aero theme, 
WPF should look for an assembly called <CODE>PresentationFramework.Aero</CODE> 
for Aero-specific resources. (You can see this very assembly in your GAC.)</P>
<P>Having worked out which assembly it's going to look in, it will then look for 
a specific named resource. The resource name always starts "/themes/" and then 
is based on the theme name, including the colour scheme. For example, Aero 
resources would be in "/themes/Aero.NormalColor.xaml". Windows 2000-style 
resources would be in "/themes/Classic.xaml" because there will only ever be one 
colour scheme for that theme. Luna is available in various colour, so 
"/themes/Luna.Metallic.xaml" would contain the silver resources, while 
"/themes/Luna.Homestead.xaml" contains olive, while 
"/themes/Luna.NormalColor.xaml" contains the normal tellytubby blue 
resources.</P>
<P>You can load up these resource dictionaries for yourself if you want. You 
need to build a relative pack URI that incorporates the component name and 
resource name. Here's one for WPF's Aero resources:</P>
<P><CODE>"/</CODE><CODE>PresentationFramework.Aero</CODE><CODE>, 
Version=3.0.0.0, Culture=neutral, 
PublicKeyToken=31bf3856ad364e35;component/themes/Aero.NormalColor.xaml"</CODE></P>
<P>You then wrap this in a relative <CODE>Uri</CODE> object and pass it to 
<CODE>Application.LoadComponent</CODE>. It will return you a 
<CODE>ResourceDictionary</CODE> containing all the Aero-specific system-scope 
resources. Here's a function that does most of the work:</P><PRE><SPAN style="COLOR: blue">public</SPAN> <SPAN style="COLOR: blue">static</SPAN> <SPAN style="COLOR: dimgray">ResourceDictionary</SPAN> LoadThemeDictionary(<SPAN style="COLOR: dimgray">Type</SPAN> t,
    <SPAN style="COLOR: blue">string</SPAN> themeName, <SPAN style="COLOR: blue">string</SPAN> colorScheme)
{
    <SPAN style="COLOR: dimgray">Assembly</SPAN> controlAssembly = t.Assembly;
    <SPAN style="COLOR: dimgray">AssemblyName</SPAN> themeAssemblyName = controlAssembly.GetName();

    <SPAN style="COLOR: blue">object</SPAN>[] attrs = controlAssembly.GetCustomAttributes(
        <SPAN style="COLOR: blue">typeof</SPAN>(<SPAN style="COLOR: dimgray">ThemeInfoAttribute</SPAN>), <SPAN style="COLOR: blue">false</SPAN>);
    <SPAN style="COLOR: blue">if</SPAN> (attrs.Length &gt; 0)
    {
        <SPAN style="COLOR: dimgray">ThemeInfoAttribute</SPAN> ti = (<SPAN style="COLOR: dimgray">ThemeInfoAttribute</SPAN>) attrs[0];

        <SPAN style="COLOR: blue">if</SPAN> (ti.ThemeDictionaryLocation == 
                             <SPAN style="COLOR: dimgray">ResourceDictionaryLocation</SPAN>.None)
        {
            <SPAN style="COLOR: green">// There are no theme-specific resources.</SPAN>
            <SPAN style="COLOR: blue">return</SPAN> <SPAN style="COLOR: blue">null</SPAN>;
        }

        <SPAN style="COLOR: blue">if</SPAN> (ti.ThemeDictionaryLocation ==
                <SPAN style="COLOR: dimgray">ResourceDictionaryLocation</SPAN>.ExternalAssembly)
        {
            themeAssemblyName.Name += <SPAN style="COLOR: brown">"."</SPAN> + themeName;
        }
    }

    <SPAN style="COLOR: blue">string</SPAN> relativePackUriForResources = <SPAN style="COLOR: brown">"/"</SPAN> +
        themeAssemblyName.FullName +
        <SPAN style="COLOR: brown">";component/themes/"</SPAN> +
        themeName + <SPAN style="COLOR: brown">"."</SPAN> +
        colorScheme + <SPAN style="COLOR: brown">".xaml"</SPAN>;

    <SPAN style="COLOR: dimgray">Uri</SPAN> resourceLocater = <SPAN style="COLOR: blue">new</SPAN> System.<SPAN style="COLOR: dimgray">Uri</SPAN>(
        relativePackUriForResources,  System.<SPAN style="COLOR: dimgray">UriKind</SPAN>.Relative);
    <SPAN style="COLOR: blue">return</SPAN> <SPAN style="COLOR: dimgray">Application</SPAN>.LoadComponent(resourceLocater)
               <SPAN style="COLOR: blue">as</SPAN> <SPAN style="COLOR: dimgray">ResourceDictionary</SPAN>;
}
</PRE>
<P></P>
<P>This code isn't quite the whole story, because it doesn't do fallback to 
generic resources when theme-specific ones are not present. A 
"/themes/generic.xaml" can be present to use when theme-specific resources 
cannot be found. However, it does finally get us to the answer to: where does 
the template come from?</P>
<P>We can call this method passing in 
<CODE>typeof</CODE><CODE>(</CODE><CODE>Button)</CODE>, "Aero", and 
"NormalColor", and we will be returned a <CODE>ResourceDictionary</CODE>. This 
dictionary will contain a <CODE>Style</CODE> for the key 
<CODE>typeof</CODE><CODE>(</CODE><CODE>Button)</CODE>. This style actually 
contains very little, but its <CODE>BasedOn</CODE> property refers to a 
<CODE>Style</CODE> for <CODE>ButtonBase</CODE>, and that is what supplies a 
setter that determines the button's default value for the <CODE>Template</CODE> 
property.</P></DIV></DIV>
<DIV class=blogBody>
<HR>
<SPAN class=copyright>Copyright © 2002-2007, <A id=ctl00_homeLink 
href="http://www.interact-sw.co.uk/">Interact Software Ltd.</A> Content by <A 
href="mailto:ian@interact-sw.co.uk">Ian Griffiths</A>. Please direct all Web 
site inquiries to <A 
href="mailto:webmaster@interact-sw.co.uk">webmaster@interact-sw.co.uk</A></SPAN> 
</DIV></BODY></HTML>
